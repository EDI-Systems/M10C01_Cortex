memory model 的本阶段研究主要基于内存的一致性方面
						Time, Clocks, and the Ordering of Events in a Distributed System
1978这篇经典论文提出了逻辑时钟的概念，为分布式系统中的事件排序和一致性问题提供了基础理论。虽然不是直接关于内存模型，但它在理解分布式系统中的一致性方面具有重要意义。
“发生在之前”的概念定义了分布式多进程系统中事件的不变部分排序。描述了一种将部分排序扩展为某种程度上任意的全排序的算法，并展示了如何使用这种全排序来解决一个简单的同步问题。
这个想法对于理解任何多进程系统都是有用的。有助于人们独立于解决多处理问题的机制来理解多处理的基本问题
						How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs
1979这篇论文提出了“序列一致性”模型，这是最早的内存一致性模型之一，为多处理器系统中并发程序的正确执行提供了基础
许多大型顺序计算机以不同于程序指定的顺序执行操作。如果生成的结果与按顺序执行程序步骤所产生的结果相同，则实现了正确的执行。对于多处理器计算机，每个处理器的正确执行并不能保证整个程序的正确执行。给出了保证计算机正确执行多进程程序的附加条件。
作者在一个多处理器的简单样例中阐述了如何保留顺序一致性的逻辑属性(对不同存储单元的请求可能会被乱序处理，但顺序一致性得到保留)
						Memory Access Buffering in Multiprocessors
1986这篇论文研究了多处理器系统中的内存访问缓冲问题，提出了影响深远的缓冲一致性模型
在多处理器体系结构中，由于每个处理器的成本很高，因此保持处理器的高效率非常重要。处理器的高利用率是由稳定的、不间断的指令和操作数保证的。必须使用内存访问的流水线和缓冲，以便以非常短的周期时间弥合较慢的共享内存和执行单元之间的差距
从存储器访问缓冲的角度对三种不同的多处理机系统进行了研究。这些结构代表了共享内存多处理器的系统结构。
1、共享全局内存系统：具有共享全局内存和私有本地内存的多处理器。所有处理器都可以访问共享内存。本地内存与特定的处理器相关联，不包含任何共享数据
2、分布式全局存储器：系统具有分布式全局存储器的多处理器，它由本地存储器的互连组成。本地内存包含全局和私有数据，并且是随机访问的(不存在数据的多个副本)
3、基于缓存的系统：具有共享全局内存和私有缓存的多处理器。共享内存包含代码和数据，缓存是关联访问的

如果任何执行的结果与所有处理器的操作按某种顺序执行的结果相同，并且每个处理器的操作按其程序指定的顺序出现在该序列中，则系统是顺序一致的。
如果LOAD指令返回的值始终是具有相同地址的最新STORE指令给出的值，则内存方案是一致的。

多处理器系统的强排序：(1)单个处理器对全局数据的访问是按顺序的(2)若处理器2观察到处理器1是对全局数据的操作时，在处理器1结束之前所有对全局数据的访问都必须对处理器2执行
弱排序：(1)满足强排序第一条(2)在所有先前的全局数据访问被执行之前，处理器中没有对同步变量的访问(3)在执行对同步变量的先前访问之前，处理器不会发出对全局数据的访问
在弱有序系统中，处理器可以发出共享内存请求，而不必等待先前的请求被执行。这将产生一个效率非常高的系统。在这种情况下，唯一麻烦的访问是对同步变量的访问。缓冲区控制器仍然必须记录它发出但未执行的所有缓存访问的状态，以便每次检测到对同步变量的访问时都可以执行这些访问。这样一个缓冲区的实现可能非常复杂。
						Foundations of the C++ Concurrency Memory Model
2008探讨了C++并发内存模型的基础知识，为理解现代编程语言中的内存模型提供了理论支持

提供了一个简单的编程模型。为了避免数据竞争，或者等同地，将数据竞争中涉及的变量和其他对象标识为原子。它们保证顺序一致的执行。
对于那些无法通过锁或顺序一致的原子操作来满足性能需求的少数用户，提供了低级的、显式排序的原子，以简单性换取跨平台性能。
(1)顺序一致的原子:无数据争用模型，要求所有非普通数据操作呈现顺序一致。
(2)Trylock和对数据竞争定义的影响:像Trylock这样的同步原语可以以非直观的方式使用，而以前需要更复杂的数据竞争定义和/或过于严格的隔离。给出一个简单的方法来解决这个问题。
(3)数据竞争的语义:不为具有数据竞争的程序提供任何语义。

作者认为，在标准化过程中，对顺序一致原子的独占支持是不可行的，主要有两个原因:
在某些现有处理器上实现它的成本足够高，因此认为有必要为性能关键代码提供“仅供专家使用”的替代方案。
现有代码通常以一种假设弱内存排序语义的方式编写，并依赖于程序员显式地提供所需的平台相关硬件指令来强制执行必要的排序。




	Memory_model一致性模型
						Memory Consistency Models
1993，451cite
顺序一致性保证了n个处理器的任何执行的结果都是相同的，就好像所有处理器的操作都按照某种顺序执行，并且每个单独处理器的操作按照程序指定的顺序出现在这个序列中。
然而，这个模型严重限制了可能的优化集合。例如，在具有高延迟内存的体系结构中，管道写访问和使用写缓冲区将是有益的。
在严格的顺序一致性模型中，这些优化都不可能实现。模拟表明，允许这种优化的较弱模型可以比严格顺序模型提高10%到40%的性能。然而，削弱内存一致性模型与编程模型的更改是密切相关的。通常，随着一致性模型变得更弱，编程模型变得更受限制(和复杂)。
简而言之，较弱的内存一致性模型可以对并行共享内存机器的性能产生积极影响。随着内存延迟的增加，好处也会增加。近年来，处理器性能的增长速度明显快于存储系统性能。除此之外，内存延迟会随着系统中处理器数量的增加而增加。

一般来说，模型区分的属性越多，模型就越弱。模型可以区分的一些属性:访问的方式、访问的方向(读、写或双向)、访问中传递的值、访问的因果关系、访问的类别

原子一致性AC：
所有一致性模型中最严格的。使用原子一致性，操作在操作间隔中的某个点生效。例如，内存总线的时钟周期可以用作操作间隔。允许在相同的操作间隔内进行多次访问，如果在相同的操作间隔内对同一位置进行读和写操作，则会导致问题。
在评估内存一致性模型的性能时，原子一致性通常用作标准

顺序一致性SC：
Lamport在1979年定义，在顺序一致的系统中，所有处理器必须就观察到的效果的顺序达成一致，就好像所有处理器的操作按照某种顺序执行，并且每个单独处理器的操作按照其程序指定的顺序出现在这个序列中。
顺序一致性长期以来一直是规范的内存一致性模型。然而，许多机器实际上实现了一种稍弱的模型，称为处理器一致性


因果一致性CC：
Hutto和Ahamad引入了因果一致性。通过将写解释为消息发送事件，将读解释为消息读取事件，可以将此概念应用于内存系统。如果所有处理器都同意因果相关事件的顺序，则内存是因果一致的。因果无关的事件(并发事件)可以以不同的顺序观察。
CC主要是理论上的兴趣，因为它比处理器一致性更严格，更难以实现


处理器一致性PC和流水线一致性PRAM：
Lipton和Sandberg定义了PipelinedRAM (PRAM)一致性模型，该模型相当于Goodman提出的处理器一致性(Processor consistency, PC)模型。
这个模型的动机是允许写访问的流水线化。流水线操作可能会延迟写操作的效果。因此，它放宽了写操作的一些顺序约束。单个处理器的写操作仍然按顺序执行
PC和SC之间的差异非常微妙，Goodman声称大多数应用程序在这两种模型下给出相同的结果。处理器一致的机器比顺序一致的系统更容易构建。

慢内存：
PC相对弱化的一种表现。它要求所有处理器就单个处理器对每个位置观察到的写的顺序达成一致。此外，本地写必须立即可见。
模型的名称是因为写入在系统中传播缓慢。慢内存可能是仍然可以用于进程间通信的最弱的统一一致性模型之一。
该算法只能保证物理排斥。没有逻辑排除的保证，对一个位置的访问已经执行的知识不能用来推断对其他位置的访问也已经执行。慢内存似乎没有任何实际意义。

弱一致性WC：
如果内存系统强制执行以下限制，则它是弱一致性的:
对同步变量的访问顺序一致。在所有先前的数据访问都被执行之前，处理器中不会发出对同步变量的访问。
在先前对同步变量的访问被执行之前，处理器不会发出任何访问，在执行同步访问时，保证所有以前的访问都已执行，并且保证所有将来的访问都未执行。

释放一致性RC：
在对一个共享变量进行普通访问之前，进程在之前所有的获得锁而进行的操作必须成功的完成。在释放一个锁操作之前，进程之前的读和写操作必须已经完成。
释放一致性仅仅关注被锁住的共享内存变量，仅仅只需要将对被锁住的共享变量的修改通知给其它的处理器。

进入一致性EC：
比RC更弱。然而，它对编程模型施加了更多的限制。EC类似于RC，只是每个共享变量都需要与一个同步变量相关联
这使得访问不同的临界区可以同时进行，这在RC下是不可能的。
EC的另一个特点是它将获取访问访问细化为排他性和非排他性。这再次增加了潜在的并发性，因为可以并发地授予对同一同步变量的非排他性获取。
该模型是第一个专门设计用于实现软件共享内存系统的模型。